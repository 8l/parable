#!/usr/bin/env python

# parable
# copyright (c) 2013 charles childers
#
# This is an attempt to separate out the execution side of things from
# the main Punga environment. As such it's being assembled as a simple
# web service.
#
# Perform a POST to http://forthworks.com/punga/python/run.py with a
# "code" field set to the code you want to run. The resulting stack,
# stack types, provided code, and any errors will be returned as a JSON
# object.


import sys
import cgi
import cgitb
import signal
import json
import parable
from parable import *

cgitb.enable()  # for troubleshooting

def handler(signum, frame):
    print "Content-Type: application/json"
    print
    report('FATAL ERROR: Execution exceed max runtime permitted')
    print get_results()
    sys.exit('fatal error: execution runtime exceeded')

signal.signal(signal.SIGALRM, handler)
signal.alarm(30)
parable.MAX_SLICES = 8192
parable.SLICE_LEN = 256

message = ""


def get_results():
    """export a parable session to the specified format"""
    global errors, stack, types, message
    sequence = []
    i = 0
    while i < len(stack):
        if types[i] == TYPE_NUMBER:
            sequence.append("#" + unicode(stack[i]))
        elif types[i] == TYPE_CHARACTER:
            sequence.append("$" + unicode(unichr(stack[i])))
        elif types[i] == TYPE_STRING:
            sequence.append("'" + unicode(slice_to_string(stack[i])) + "'")
        elif types[i] == TYPE_FUNCTION:
            sequence.append("&" + unicode(stack[i]))
        elif types[i] == TYPE_FLAG:
            if stack[i] == -1:
                sequence.append("true")
            elif stack[i] == 0:
                sequence.append("false")
            else:
                sequence.append("malformed flag")
        else:
            sequence.append("unmatched type on stack!")
        i = i + 1
    collect_unused_slices()

    p_map = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            p_map.append(i)
        i = i + 1
    p_slices = []
    i = 0
    while i < parable.MAX_SLICES:
        if parable.p_map[i] != 0:
            p_slices.append(parable.p_slices[i])
        else:
            p_slices.append([])
        i = i + 1

    return json.dumps({"symbols": dictionary_names, "symbol_map": dictionary_slices, "errors": errors, "raw_stack": stack, "parsed_stack": sequence, "types": types, "code": message, "slices": p_slices, "memory_map": p_map})


def process_input():
    global message
    form = cgi.FieldStorage()
    message = form.getvalue("code", " ")
    prepare_slices()
    prepare_dictionary()
    parse_bootstrap(open('bootstrap.p').readlines())
    collect_unused_slices()
    f = message.split("\n")
    counter = 0
    for line in f:
        if len(line) >= 1:
            s = compile(line, request_slice())
            interpret(s)
            counter += 1
            if counter > 100:
                if len(stack) == 0:
                    collect_unused_slices()
                    counter = 0


if __name__ == '__main__':
     process_input()
     print "Content-Type: application/json"
     print
     print get_results()
